#!/usr/bin/env python
# -*- coding: utf-8 -*-
# encoding: utf-8

import __future__
import re
import sys
import argparse
import subprocess
# import the template
from template import *

DEBUG = False

##
# @brief Data object of a function extracted form the abstract syntax tree of
# the pycparser
class Function():

	def __init__(self):

		# Return type of the function (int*, char, etc.) 
		self.type= ''
		self.name = ''
		# A list of Parameters, a parameter is a extra class for storing 
		self.parameters = []
		self.signature = ''
	#end def

	##
	# @brief Returns the function identifier.
	#
	# @return The identifier which is the signature of the function without
	# white space 
	def getIdentifier(self):
		params = ''	

		for param in self.parameters:
			params += '%s,' % (param.__str__())
		#end for
		
		# Truncate the last ,
		params = params[:-1]

		identifier = '%s%s(%s);' % (''.join(self.type.split(' ')),
			self.name, params)

		return identifier
	#end def
	def generateSignature(self):

			for sigpart in self.parameters:						
				sig = sigpart.type + '' + sigpart.name + ', '
				self.signature += sig
			self.signature = self.signature[:-2]
#end class

##
# @brief One parameter of a function.
class Parameter():

	def __init__(self):
		self.type = ''
		self.name = ''
	#end def

	def __str__(self):
		
		return ''.join(self.type.split(' '))+self.name
	#end def
#end class

##
# @brief The instrumentation instructions for one function. This object is
# stored inside a dict with with the identifier as key
class InstrumentedFunction():

	def __init__(self):
		self.init = False
		self.before = []
		self.after = []
	#end def
#end class

class Instruction():
	
	def __init__(self):
		self.name = ''
		self.parameters = []
	#end def
#end class

##
# @brief This class parses the abstract syntax tree generated by the pycparser
class FunctionParser():
	
	def __init__(self):

		self.functions = []
		self.regexFuncDef = re.compile('(?:;|})?(.+?)(?:;|{)' , re.M | re.S)
		self.regexFilter = re.compile('^[#/]|typedef.*')
		self.regexFuncDefParts = re.compile('(.+?)\((.+?)\).*?')
	#end def

	def parse(self,option):
		
		functions = []
		lines = ''

		if option.cpp is []:
			inputFile = open(option.inputFile, 'r')
			lines = inputFile.read()
			
		else:
			if option.cpp is '':
				cpp = subprocess.Popen(['cpp',option.inputFile], stdout=subprocess.PIPE,
						stderr=subprocess.PIPE)
				lines, error = cpp.communicate()
			
			else:
				print "-----"
				cpp = subprocess.Popen(['cpp',option.cpp, option.inputFile], stdout=subprocess.PIPE,
						stderr=subprocess.PIPE)
				lines, error = cpp.communicate()

			if error is not '':
				print error
				sys.exit(1)
		
		
		matchFuncDef = self.regexFuncDef.findall(lines)
		
		for funcNo, function in enumerate(matchFuncDef):
			
			
			function = function.split('\n')
			
			for index in range(0,len(function)):
				function[index] = function[index].lstrip()

				if self.regexFilter.match(function[index]):
						function[index] = ''

				function[index] = function[index].rstrip()
			
			function = ''.join(function)

			funcParts = self.regexFuncDefParts.match(function)

			if funcParts is None:
				continue
			
			function = Function()
			functions.append(function)
			function.type, function.name = self.getTypeName(funcParts.group(1),'function'+str(funcNo))
			
			parameters = funcParts.group(2).split(',')

			for paramNo, parameter in enumerate(parameters):
				parameterObj = Parameter()
				function.parameters.append(parameterObj)
				parameterObj.type, parameterObj.name = self.getTypeName(parameter, 'var'+str(paramNo))
		
			function.generateSignature()
		return functions

	def getTypeName(self, declaration, alternativeName=''):
		
		type = ''
		name = ''

		typeName = declaration.split('*')
		
		if typeName is '':
			name = alternativeName

		else:
			name = typeName.pop()

		for element in typeName:

			if element is '':
				type += '*'

			else:
				type += element

		return (type, name)

##O
# @brief 
class InstructionParser():

	def parse(self, functions, inputFile):
		
		# Open the input file for reading the instrumentation instructions
		inputFileHandel = open(inputFile, 'r')
		
		inputLines = inputFileHandel.readlines()

		# Get the available instrumentation commands form the imported template.p 
		commands = template.keys()
		
		# Create an ordered dict to store the 
		instructions = {}
		
		# Iterate over the function list to generate all the functions inside the
		# ordered dict
		for function in functions:
			instructions[function.getIdentifier()] = None 

		# The actual section (init, before, after) to store the instrumentation
		# instructions
		storage = None
		instrumentedFunction = InstrumentedFunction()

		for index, line in enumerate(inputLines):

			if line[:2] in "//":
				line = line.lstrip('/ \t')
				line = line.rstrip()

				wordList = line.split()

				for word in wordList:

					if word == 'before':
						storage = instrumentedFunction.before

					elif word == 'after':
						storage = instrumentedFunction.after

					elif word == 'init':
						instrumentedFunction.init = True

					elif word in commands:
						
						if storage == None:
							print('ERROR: No section defined for %s at %i, please use "before", "after" or "init"' % (word, index))
							sys.exit(1)

						instruction = Instruction()
						instruction.name = word
						storage.append(instruction)

					else:
						if storage==None: 
							print('ERROR: Template name not found! %s is not a valid instrumention instruction in line %i.' % (word, index))
							sys.exit(1)
						#end if
						storage[-1].parameters.append(word)
					#end if
				#end for

			else:	
				line = line.lstrip('/ \t')
				line = line.rstrip()

				wordList = line.split()
				key = ''.join(wordList)

				if key in instructions:
					instructions[key] = instrumentedFunction
					instrumentedFunction =	InstrumentedFunction()


		return instructions	




def Option():

	# FIXME: sort the options
	argParser = argparse.ArgumentParser(description='''Wraps SIOX function
			around library function calls''')

	argParser.add_argument('--output', '-o', action='store', nargs=1,
			dest='outputFile', default="out.c", help='out')
	
	argParser.add_argument('--debug', '-d', action='store_true', default=False,
			dest='debug', help='''Print out debug information.''')

	argParser.add_argument('--blankHeader', '-b', action='store_true',
			default=False, dest='blankHeader', help='''Generate a clean header file''')

	argParser.add_argument('--cpp', '-c', action='store', default='', nargs='?',
			dest='cpp', help='Use cpp to filter the input file.')

	argParser.add_argument('inputFile', default=None, 
	help='Source or header file to parse')

	args = argParser.parse_args()

	if args.outputFile:
		args.outputFile = args.outputFile[0]

	return args


def writeHeaderFile(options, functions):
	# open the output file for writing
	file = open(options.outputFile, 'w')
	# function headers
	for function in functions:
		file.write("%s %s ( %s ); \n" % (function.type, function.name, function.signature))

	# close the file
	file.close()

def writeSourceFile(options, functions, instructions):

	# open the output file for writing	
	file = open(options.outputFile, 'w')
	
	# includes
	for i in includes:
		file.write(i+"\n")
	file.write("\n")

 	# global variables
	for i in variables:
		file.write(i+"\n")
	file.write("\n")

	# function headers
	for function in functions:
		file.write("%s  __real_%s(%s);\n"  % (function.type, function.name, function.signature))
	file.write("\n")

	# function definitions
	for function in functions:
		file.write("%s __wrap_%s(%s) {\n" % (function.type, function.name, function.signature))

		# look for instructions
		if function.getIdentifier() in instructions:
			lines = instructions[function.getIdentifier()]

			# is this the desired init-function? If yes, write all inits
			if lines.init:
				for inits in template.itervalues():
					file.write(inits["init"]+'\n')	

			# write given befores
			for line in lines.before:
				if template[line.name] != "":
					file.write("%s \n" % (template[line.name]["before"] % tuple(line.parameters)))

		# write the function call
		varNames = ''
		for parameter in function.parameters:
			varNames += parameter.name + ', '
		varNames = varNames[:-2]
		file.write("%s ret = __real_%s(%s);\n" % (function.type, function.name, 
			varNames))

		# look for instructions
		if function.getIdentifier() in instructions:
			lines = instructions[function.getIdentifier()]
			for line in lines.after:
				# write all given afters
				if template[line.name] != "":
					file.write("%s \n" % (template[line.name]["after"] % tuple(line.parameters)))

		file.write("return ret;\n}\n\n")

	# close the file
	file.close()

	
#
# start of the main program
#
def main():
	# parse the options
	opt = Option()
	DEBUG = opt.debug
	
	functionParser = FunctionParser()
	functions = functionParser.parse(opt)
	
	if opt.blankHeader:
		# only generate a header-skeleton for the user to comment
		writeHeaderFile(opt, functions)

	else:
		# use the header-skeleton commented by the user to generate the instrumented library
		instructions = InstructionParser()
		instr = instructions.parse(functions, opt.inputFile)
		writeSourceFile(opt, functions, instr)

main()
